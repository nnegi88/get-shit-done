---
phase: 01.1-migrate-gsd-from-subagents-to-agent-teams
plan: 03
type: execute
wave: 2
depends_on: [01.1-01]
files_modified:
  - ~/.claude/get-shit-done/workflows/execute-phase.md
  - ~/.claude/get-shit-done/workflows/execute-plan.md
autonomous: true

must_haves:
  truths:
    - "Execute-phase workflow creates a team with per-wave executor teammates and a verifier"
    - "Parallel executors can broadcast warnings about shared dependency changes in real-time"
    - "Verifier can query executors about discrepancies found during verification"
    - "Wave-based execution order is preserved via TaskCreate dependency chains (addBlockedBy)"
    - "Workflow falls back to sequential subagent spawning if TeamCreate fails"
    - "All existing execute-phase functionality preserved (init, wave grouping, checkpoint handling, spot-checks, verification, resumption)"
  artifacts:
    - path: "~/.claude/get-shit-done/workflows/execute-phase.md"
      provides: "Team-based execution workflow with wave dependencies and executor cross-communication"
      contains: "TeamCreate"
    - path: "~/.claude/get-shit-done/workflows/execute-plan.md"
      provides: "Updated execution context for teammate-mode executors"
      contains: "team"
  key_links:
    - from: "~/.claude/get-shit-done/workflows/execute-phase.md"
      to: "~/.claude/agents/gsd-executor.md"
      via: "Task() spawn with team_name parameter"
      pattern: "team_name.*gsd-exec"
    - from: "~/.claude/get-shit-done/workflows/execute-phase.md"
      to: "~/.claude/agents/gsd-verifier.md"
      via: "Task() spawn with team_name for post-execution verification"
      pattern: "team_name.*gsd-exec"
---

<objective>
Migrate the execute-phase.md and execute-plan.md workflows from sequential subagent spawning to Agent Teams with wave-based task dependencies and real-time executor coordination.

Purpose: The current execute-phase spawns executors per-wave without coordination. With Agent Teams, parallel executors in the same wave can broadcast warnings about shared dependency changes, and the verifier can query executors about discrepancies. Wave ordering is preserved via TaskCreate's addBlockedBy instead of sequential spawning.

Output: Rewritten execute-phase.md with team orchestration and fallback, updated execute-plan.md for teammate context.
</objective>

<execution_context>
@/Users/naveennegi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/naveennegi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01.1-migrate-gsd-from-subagents-to-agent-teams/01.1-RESEARCH.md
@.planning/phases/01.1-migrate-gsd-from-subagents-to-agent-teams/CONTEXT.md
@.planning/phases/01.1-migrate-gsd-from-subagents-to-agent-teams/01.1-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite execute-phase.md for team-based wave execution with fallback</name>
  <files>
    ~/.claude/get-shit-done/workflows/execute-phase.md
  </files>
  <action>
    Rewrite `execute-phase.md` to use Agent Teams while preserving ALL existing functionality. The workflow must attempt team-based orchestration and fall back to the current subagent pattern if teams are unavailable.

    **Steps that remain IDENTICAL** (no changes needed):
    - `<purpose>` and `<core_principle>` — update text to mention team mode but keep the core idea
    - `<required_reading>` — unchanged
    - Step: `initialize` — unchanged (same init loading)
    - Step: `handle_branching` — unchanged
    - Step: `validate_phase` — unchanged
    - Step: `discover_and_group_plans` — unchanged (still uses phase-plan-index)
    - `<context_efficiency>` — update to mention team mode
    - `<failure_handling>` — add team-specific failure handling (teammate crash)
    - `<resumption>` — update to mention team recovery

    **Step: execute_waves — MAJOR RESTRUCTURE for team mode:**

    After discover_and_group_plans, attempt team creation:

    ```
    ## Team Creation (or Fallback)

    TeamCreate({ team_name: "gsd-exec-{phase_number}", description: "Execution team for Phase {phase_number}: {phase_name}" })

    If TeamCreate succeeds — TEAM MODE:
    ```

    **In team mode, create ALL tasks upfront with dependency chains:**

    ```
    For each wave (1, 2, 3, ...):
      For each plan in wave:
        task = TaskCreate({
          subject: "Execute Plan {plan_id}: {plan_objective}",
          description: "Execute {plan_file}. Commit each task atomically. Create SUMMARY.md.",
          activeForm: "Executing plan {plan_id}"
        })
        # If wave > 1, add dependencies on all tasks from previous wave
        If wave > 1:
          TaskUpdate({ taskId: task.id, addBlockedBy: [all task IDs from previous wave] })

    # Verifier task depends on ALL execution tasks
    verifier_task = TaskCreate({
      subject: "Verify phase {phase_number} goal achievement",
      description: "Check must_haves against actual codebase. Create VERIFICATION.md.",
      activeForm: "Verifying phase goal",
      addBlockedBy: [all execution task IDs]
    })
    ```

    **Spawn executor teammates (one per plan, all at once):**

    ```
    For each plan (across all waves):
      Task(
        team_name: "gsd-exec-{phase_number}",
        name: "executor-{plan_id}",
        subagent_type: "gsd-executor",
        prompt: "
          <objective>
          Execute plan {plan_number} of phase {phase_number}-{phase_name}.
          You are a teammate on an execution team. Check TaskList() for your task.
          Your task may be blocked — wait until it becomes available, then claim and execute.
          Commit each task atomically. Create SUMMARY.md. Update STATE.md.
          </objective>

          <team_awareness>
          You are executor-{plan_id} on team gsd-exec-{phase_number}.
          Other executors may be running in parallel. If you modify a file that could affect others:
          - Broadcast a warning: SendMessage({ type: 'broadcast', content: 'Modified {file}', summary: '{file} changed' })
          If another executor broadcasts about a file you depend on, check your imports.
          </team_awareness>

          <execution_context>
          @/Users/naveennegi/.claude/get-shit-done/workflows/execute-plan.md
          @/Users/naveennegi/.claude/get-shit-done/templates/summary.md
          @/Users/naveennegi/.claude/get-shit-done/references/checkpoints.md
          @/Users/naveennegi/.claude/get-shit-done/references/tdd.md
          </execution_context>

          <files_to_read>
          Read these files at execution start using the Read tool:
          - Plan: {phase_dir}/{plan_file}
          - State: .planning/STATE.md
          - Config: .planning/config.json (if exists)
          </files_to_read>
        "
      )
    ```

    **Spawn verifier teammate:**

    ```
    Task(
      team_name: "gsd-exec-{phase_number}",
      name: "verifier",
      subagent_type: "gsd-verifier",
      prompt: "
        You are the verifier on an execution team. Check TaskList() for your task.
        Your task is blocked until all executors complete. When unblocked, claim and verify.

        IMPORTANT: If you find discrepancies between SUMMARY.md claims and codebase:
        - Message the specific executor: SendMessage({ type: 'message', recipient: 'executor-{plan_id}', content: 'Discrepancy: ...', summary: 'Verification discrepancy' })
        - Wait for response before marking as gap

        Phase directory: {phase_dir}
        Phase goal: {goal from ROADMAP.md}
        Check must_haves against actual codebase. Create VERIFICATION.md.
      "
    )
    ```

    **Orchestrator monitoring in team mode:**

    ```
    Monitor team progress:
    - Use TaskList() to check task statuses
    - Report wave completions as tasks complete (same wave completion banners as current)
    - For each completed execution task, run the same spot-checks:
      * Verify SUMMARY.md exists
      * Check git commits present
      * Check for Self-Check: FAILED marker
    - Handle checkpoint plans: if a task requires human interaction, the executor sends a message to the team lead
    - When verifier task completes, read VERIFICATION.md status
    ```

    **Checkpoint handling in team mode:**

    Checkpoint plans (autonomous: false) in team mode work as follows:
    - The executor reaches a checkpoint and messages the team lead:
      `SendMessage({ type: "message", recipient: "team-lead", content: "CHECKPOINT: {type}\n{details}\nAwaiting user input.", summary: "Checkpoint reached" })`
    - The orchestrator (lead) presents the checkpoint to the user (same as current step 4 of checkpoint_handling)
    - After user responds, the orchestrator messages the executor:
      `SendMessage({ type: "message", recipient: "executor-{plan_id}", content: "User response: {response}\nContinue execution.", summary: "Checkpoint resolved" })`
    - The executor continues from where it paused (advantage: same session, no context loss)

    **Shutdown sequence (team mode):**

    ```
    After all tasks complete and verification done:
    For each teammate:
      SendMessage({ type: "shutdown_request", recipient: teammate, content: "Phase execution complete" })
      # Wait for shutdown_response
    TeamDelete()
    ```

    **If TeamCreate fails — FALLBACK to current mode:**

    Display: `Agent Teams unavailable. Using sequential subagent mode.`

    Execute the EXACT current execute_waves step logic: sequential wave execution, per-wave subagent spawning, spot-checks, checkpoint handling via continuation agents, verifier as separate subagent. Preserve this code verbatim as the fallback path.

    **Preserve these existing behaviors exactly in both modes:**
    - Wave-based execution order
    - Spot-check verification (SUMMARY.md exists, git commits, Self-Check marker)
    - Checkpoint handling (pause/resume with user interaction)
    - classifyHandoffIfNeeded bug workaround
    - aggregate_results step
    - verify_phase_goal step
    - update_roadmap step
    - offer_next step
    - Resumption behavior (skip plans with existing SUMMARYs)
    - --gaps-only filtering
  </action>
  <verify>
    1. `grep "TeamCreate" ~/.claude/get-shit-done/workflows/execute-phase.md` finds team creation
    2. `grep "addBlockedBy" ~/.claude/get-shit-done/workflows/execute-phase.md` finds task dependency chains
    3. `grep "broadcast" ~/.claude/get-shit-done/workflows/execute-phase.md` finds executor broadcast pattern
    4. `grep "SendMessage.*verifier\|SendMessage.*executor" ~/.claude/get-shit-done/workflows/execute-phase.md` finds verifier-executor messaging
    5. `grep "TeamDelete" ~/.claude/get-shit-done/workflows/execute-phase.md` finds cleanup
    6. `grep "fallback\|FALLBACK\|subagent mode" ~/.claude/get-shit-done/workflows/execute-phase.md` finds fallback path
    7. The file still contains checkpoint_handling, spot-checks, classifyHandoffIfNeeded workaround
  </verify>
  <done>
    execute-phase.md creates an execution team with per-plan executor teammates and a verifier. Wave ordering is preserved via addBlockedBy task dependencies. Parallel executors can broadcast about shared dependency changes. Verifier queries executors about discrepancies before marking gaps. Checkpoint handling preserves session context. Falls back to current sequential mode if TeamCreate fails. All existing functionality preserved.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update execute-plan.md for teammate execution context</name>
  <files>
    ~/.claude/get-shit-done/workflows/execute-plan.md
  </files>
  <action>
    Update `execute-plan.md` to support operation both as a standalone subagent (current mode) and as a teammate on an execution team.

    **Add a team awareness section** near the top of the process, after the `<required_reading>` section:

    ```xml
    <team_context>
    ## Teammate Mode

    When executing as a teammate on an execution team (you will see team context in your session):

    1. **Task Management:** Check TaskList() on start. Your task may be blocked by previous wave executors. Wait until your task is available, then claim it with TaskUpdate.

    2. **Cross-Executor Coordination:** If you modify a file that other executors might depend on (shared utilities, types, config), broadcast:
       `SendMessage({ type: "broadcast", content: "Modified {file}: {what changed}", summary: "{file} exports changed" })`

    3. **Checkpoint Escalation:** If you reach a checkpoint task, message the team lead instead of returning:
       `SendMessage({ type: "message", recipient: "team-lead", content: "CHECKPOINT REACHED\nType: {type}\nDetails: {details}\nAwaiting user input.", summary: "Checkpoint: {type}" })`
       Wait for the team lead's response message, then continue execution.

    4. **Completion:** After creating SUMMARY.md and updating STATE.md, mark your task completed:
       `TaskUpdate({ taskId: "N", status: "completed" })`

    5. **Failure:** If execution fails, message the team lead with failure details before marking task as failed.

    When NOT on a team (spawned as standalone subagent), ignore this section and follow the standard execution flow below.
    </team_context>
    ```

    **No other changes to execute-plan.md.** The existing execution flow (init_context, identify_plan, parse_segments, execute_tasks, commit, summary, etc.) remains identical. The team_context section only activates when the executor detects team context in its session.

    This is a minimal, additive change that preserves backward compatibility.
  </action>
  <verify>
    1. `grep "team_context\|Teammate Mode" ~/.claude/get-shit-done/workflows/execute-plan.md` finds the new section
    2. `grep "SendMessage" ~/.claude/get-shit-done/workflows/execute-plan.md` finds team communication instructions
    3. The existing `<process>` section is unchanged
    4. The file still starts with `<purpose>` and contains `<required_reading>`
  </verify>
  <done>
    execute-plan.md has a team_context section that activates when the executor is a teammate, enabling cross-executor broadcasts, checkpoint escalation via messaging, and task status management. Standalone subagent execution is completely unchanged.
  </done>
</task>

</tasks>

<verification>
1. execute-phase.md supports team mode (task dependency chains, parallel executor spawning, verifier querying) and fallback mode
2. execute-plan.md supports both teammate mode (broadcasts, checkpoint messaging, task updates) and standalone mode
3. Wave-based execution order is preserved via addBlockedBy in team mode and sequential spawning in fallback
4. Parallel executors can broadcast shared dependency changes (team mode)
5. Verifier can query executors about discrepancies (team mode)
6. All existing functionality (spot-checks, checkpoints, resumption, --gaps-only, classifyHandoffIfNeeded) preserved in both modes
</verification>

<success_criteria>
The execution workflow creates a team where parallel executors coordinate in real-time and the verifier queries executors about discrepancies, with fallback to sequential mode.
</success_criteria>

<output>
After completion, create `.planning/phases/01.1-migrate-gsd-from-subagents-to-agent-teams/01.1-03-SUMMARY.md`
</output>
