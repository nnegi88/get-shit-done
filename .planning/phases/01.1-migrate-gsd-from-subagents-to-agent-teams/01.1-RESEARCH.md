# Phase 01.1: Migrate GSD from Subagents to Agent Teams - Research

**Researched:** 2026-02-09
**Domain:** Claude Code Agent Teams orchestration, multi-agent coordination, workflow migration
**Confidence:** MEDIUM-HIGH

## Summary

The migration from fire-and-forget subagent spawning (`Task()`) to Agent Teams orchestration requires replacing the current sequential file-handoff communication pattern with persistent teammate sessions that use direct messaging (`SendMessage`), shared task lists (`TaskCreate/TaskUpdate/TaskList`), and centralized team coordination. The current GSD architecture has 11 agent types across 3 primary orchestrator workflows (plan-phase, execute-phase, new-project) plus a debug workflow, all communicating exclusively through files (RESEARCH.md, PLAN.md, SUMMARY.md, STATE.md). Agent Teams gives each agent its own Claude Code session with the ability to message other agents directly, enabling follow-up questions between researcher and planner, direct revision loops between checker and planner, and real-time coordination between parallel executors.

The migration is feasible but requires careful attention to Agent Teams limitations: the feature is experimental (requires `CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1`), supports only one team per session, has no session resumption for in-process teammates, and the team lead is fixed once created. Each workflow must be migrated independently, with the existing file-based artifact system preserved as the persistent state layer. The key architectural shift is that orchestrator workflows change from spawning sequential `Task()` calls to creating a team, spawning teammates with `Task()`, coordinating through `TaskCreate` with dependency chains (`addBlockedBy`), and tearing down with `SendMessage(shutdown_request)` followed by `TeamDelete`.

**Primary recommendation:** Migrate plan-phase workflow first (lowest risk, clearest benefit from researcher-planner-checker direct messaging), then execute-phase (parallel executor coordination), then new-project (parallel research cross-pollination), and finally debug (competing hypothesis pattern). Implement graceful fallback to subagent mode for each workflow independently.

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions
- Agent Teams is the target orchestration model (no alternatives)
- File-based artifacts remain the source of truth
- gsd-tools.js CLI unchanged
- User-facing slash commands unchanged

### Claude's Discretion
- Order of workflow migration (plan-phase first recommended)
- Meta-prompt structure and content
- Team naming conventions
- Whether to implement graceful fallback to subagents or hard-cut
- Hook integration depth

### Deferred Ideas (OUT OF SCOPE)
- Custom MCP server for team coordination
- Persistent team sessions across /clear boundaries
- Team performance analytics
</user_constraints>

## Standard Stack

### Core

| Component | Version | Purpose | Why Standard |
|-----------|---------|---------|--------------|
| Agent Teams API | Experimental (2026) | Team creation, task management, messaging | Only official multi-agent coordination system in Claude Code |
| `TeamCreate` | Current | Create team with shared task list | Required entry point for all team workflows |
| `TaskCreate/Update/List/Get` | Current | Shared task management with dependencies | Replaces wave-based file coordination with programmatic task graphs |
| `SendMessage` | Current | Direct messaging (DM, broadcast, shutdown) | Replaces file-only communication between agents |
| `TeamDelete` | Current | Clean up team resources | Required for session cleanup |
| `Task()` with `team_name` | Current | Spawn teammates into existing team | Same spawn mechanism but with team membership |

### Supporting

| Component | Purpose | When to Use |
|-----------|---------|-------------|
| Delegate mode (Shift+Tab) | Restrict lead to coordination-only | All team workflows to prevent lead from implementing |
| `addBlockedBy` task dependency | Create task execution order | Wave-based parallelization via task dependency chains |
| `plan_mode_required` agent flag | Require plan approval before implementation | Executor teammates to ensure plan review before code changes |
| Hook: `TaskCompleted` | Validate task completion quality | Post-execution quality gates (supports prompt/agent hooks) |
| Hook: `TeammateIdle` | Detect idle teammates | Monitoring only (exit code hooks only, no prompt/agent) |

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Agent Teams | Keep subagents (Task only) | No direct messaging, no shared coordination, but simpler and lower cost |
| In-process teammates | tmux mode teammates | tmux gives terminal visibility but requires tmux installed, adds complexity |
| Direct teammate messaging | File-based messaging | Files persist across sessions but are async and require polling |

### Configuration

```json
// ~/.claude/settings.json (already configured)
{
  "env": {
    "CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS": "1"
  }
}
```

```
// Per-workflow team creation
TeamCreate({ team_name: "gsd-plan-{phase}", description: "Planning team for phase {phase}" })

// Teammate spawning with team membership
Task(
  team_name: "gsd-plan-{phase}",
  name: "researcher",
  subagent_type: "gsd-phase-researcher",
  prompt: "You are the researcher on a planning team..."
)
```

## Architecture Patterns

### Current Architecture: Sequential File Handoffs

```
Orchestrator (plan-phase.md)
    |
    +--> Task(researcher) --> writes RESEARCH.md --> returns result
    |
    +--> Task(planner, reads RESEARCH.md) --> writes PLAN.md --> returns result
    |
    +--> Task(checker, reads PLAN.md) --> returns issues
    |
    +--> Task(planner, reads issues) --> revises PLAN.md --> returns result
    |
    done
```

Each agent is spawned, does work, returns a result, and is gone. The orchestrator serializes all context into the spawn prompt. No agent can message another agent.

### Target Architecture: Team-Based Coordination

```
Orchestrator (plan-phase.md)
    |
    +--> TeamCreate("gsd-plan-{phase}")
    |
    +--> TaskCreate("Research phase domain", activeForm: "Researching...")
    +--> TaskCreate("Create execution plan", blockedBy: [research_task])
    +--> TaskCreate("Verify plan quality", blockedBy: [plan_task])
    |
    +--> Task(team_name, name: "researcher", ...) --> claims research task
    +--> Task(team_name, name: "planner", ...) --> waits for research
    +--> Task(team_name, name: "checker", ...) --> waits for plan
    |
    +--> Monitor: planner SendMessage(researcher, "Follow-up question...")
    +--> Monitor: checker SendMessage(planner, "Task 3 contradicts Task 1")
    +--> Monitor: planner revises based on direct feedback
    |
    +--> SendMessage(shutdown_request) to all teammates
    +--> TeamDelete()
```

### Pattern 1: Team Lead as Coordinator (Delegate Mode)

**What:** The team lead creates the team, spawns teammates, creates tasks with dependencies, and monitors progress. The lead never implements code.

**When to use:** All team workflows. Prevents the lead from becoming a bottleneck by doing work instead of coordinating.

**Implementation:**
```
// Lead creates team and tasks
TeamCreate({ team_name: "gsd-plan-03" })
TaskCreate({ subject: "Research error handling patterns", activeForm: "Researching..." })
TaskCreate({ subject: "Create plan for error handling", addBlockedBy: ["1"], activeForm: "Planning..." })

// Lead spawns teammates
Task(team_name: "gsd-plan-03", name: "researcher", subagent_type: "gsd-phase-researcher")
Task(team_name: "gsd-plan-03", name: "planner", subagent_type: "gsd-planner")

// Lead monitors via TaskList, responds to messages
// Lead does NOT write PLAN.md or RESEARCH.md itself
```

Source: Official Agent Teams documentation (code.claude.com/docs/en/agent-teams), verified 2026-02-09

### Pattern 2: Task Dependency Chains for Wave Execution

**What:** Replace frontmatter-based `depends_on` and `wave` fields with `addBlockedBy` task dependencies.

**When to use:** Execute-phase workflow where plans have wave assignments.

**Implementation:**
```
// Wave 1 tasks (no dependencies)
task1 = TaskCreate({ subject: "Execute Plan 01-01", activeForm: "Executing plan 01-01..." })
task2 = TaskCreate({ subject: "Execute Plan 01-02", activeForm: "Executing plan 01-02..." })

// Wave 2 tasks (depend on wave 1)
task3 = TaskCreate({ subject: "Execute Plan 01-03", addBlockedBy: [task1.id, task2.id], activeForm: "Executing plan 01-03..." })

// Verifier task (depends on all execution tasks)
task4 = TaskCreate({ subject: "Verify phase goal", addBlockedBy: [task1.id, task2.id, task3.id], activeForm: "Verifying..." })
```

Source: Agent Teams documentation, TaskCreate addBlockedBy parameter

### Pattern 3: Direct Messaging for Revision Loops

**What:** Replace sequential orchestrator-mediated revision (planner -> orchestrator -> checker -> orchestrator -> planner) with direct planner<->checker messaging.

**When to use:** Plan-phase revision loop (currently max 3 iterations).

**Implementation:**
```
// Checker finds issue, messages planner directly
SendMessage({
  type: "message",
  recipient: "planner",
  content: "Task 3 depends on Task 1 output but doesn't declare dependency. Also, Task 5 scope exceeds plan budget.",
  summary: "Plan issues: missing dep, scope creep"
})

// Planner responds after fixing
SendMessage({
  type: "message",
  recipient: "checker",
  content: "Fixed: Added Task 1 dependency to Task 3. Split Task 5 into 5a and 5b. Please re-verify.",
  summary: "Plan revised, requesting re-check"
})
```

Source: SendMessage API documentation

### Pattern 4: Broadcast for Cross-Pollination

**What:** Parallel agents broadcast discoveries relevant to other agents.

**When to use:** Research team (new-project) where 4 researchers investigate different domains, and execution team where parallel executors modify shared code.

**Implementation:**
```
// Stack researcher discovers constraint relevant to architecture researcher
SendMessage({
  type: "broadcast",
  content: "Stack finding: Selected auth library (next-auth v5) requires Redis for session storage. Architecture researcher: factor this into infrastructure design.",
  summary: "Auth requires Redis dependency"
})

// Executor discovers shared dependency change
SendMessage({
  type: "broadcast",
  content: "WARNING: I modified src/lib/helpers.ts export signature. If you import from helpers.ts, check your imports.",
  summary: "helpers.ts exports changed"
})
```

**CAUTION:** Broadcasts are expensive (N teammates = N message deliveries). Use sparingly. Default to direct `SendMessage` when only one teammate needs the information.

Source: Agent Teams documentation broadcast warnings

### Pattern 5: Graceful Fallback to Subagents

**What:** Detect Agent Teams availability and fall back to current subagent spawning if teams fail.

**When to use:** All workflows during migration transition period.

**Implementation approach:**
```
// In orchestrator workflow
try:
  TeamCreate({ team_name: "gsd-plan-{phase}" })
  // ... team-based workflow
catch:
  // Fall back to sequential Task() spawning
  // Log: "Agent Teams unavailable, using subagent mode"
  Task(subagent_type: "gsd-phase-researcher", prompt: "...", ...)
  Task(subagent_type: "gsd-planner", prompt: "...", ...)
```

**Note:** Workflows are markdown prompt files, not code. Fallback detection must be handled within the orchestrator's prompt logic by attempting TeamCreate and branching on failure.

### Recommended File Structure for Team-Aware Agents

```
~/.claude/agents/
    gsd-executor.md           # Updated with Team Communication Protocol section
    gsd-planner.md            # Updated with Team Communication Protocol section
    gsd-verifier.md           # Updated with Team Communication Protocol section
    gsd-phase-researcher.md   # Updated with Team Communication Protocol section
    gsd-plan-checker.md       # Updated with Team Communication Protocol section
    gsd-debugger.md           # Updated with Team Communication Protocol section
    gsd-project-researcher.md # Updated with Team Communication Protocol section
    gsd-research-synthesizer.md # Updated with Team Communication Protocol section
    gsd-roadmapper.md         # Minimal changes (single-agent workflow)
    gsd-integration-checker.md # Updated with Team Communication Protocol section
    gsd-codebase-mapper.md    # Minimal changes (single-agent workflow)

~/.claude/get-shit-done/workflows/
    plan-phase.md             # Rewritten for team orchestration
    execute-phase.md          # Rewritten for team orchestration
    execute-plan.md           # Rewritten for teammate execution context
    new-project.md            # Rewritten for team orchestration
    debug.md                  # New or rewritten for competing hypothesis team
```

### Anti-Patterns to Avoid

- **Lead doing implementation work:** The team lead must coordinate, not implement. Use delegate mode. If the lead starts writing PLAN.md or code, the team pattern has broken down.
- **Over-broadcasting:** Broadcasts send to ALL teammates. Use direct messages when only one teammate needs information. Broadcasts are expensive (N messages for N teammates).
- **Ignoring teammate idle state:** Teammates go idle between turns. This is normal. Do NOT treat idle as "done" or "broken." Idle teammates can receive messages and will resume.
- **Skipping shutdown before TeamDelete:** Always `SendMessage(shutdown_request)` to every teammate and wait for acknowledgment before `TeamDelete()`. Skipping this causes resource leaks.
- **Nested teams:** Agent Teams does not support teams within teams. Each workflow creates ONE team. Do not try to have an executor teammate create its own sub-team.
- **File conflicts between teammates:** Two teammates writing the same file simultaneously causes corruption. Maintain file ownership rules (one teammate per file at a time). Use wave-based task ordering to prevent conflicts.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Inter-agent messaging | Custom file-polling or socket system | `SendMessage` API | Built-in, handles queuing, delivery confirmation, idle wake-up |
| Task dependency ordering | Custom wave calculation from frontmatter | `TaskCreate` with `addBlockedBy` | Built-in dependency resolution, status tracking, blocking detection |
| Team lifecycle management | Custom session tracking | `TeamCreate` / `TeamDelete` | Handles teammate registration, config files, cleanup |
| Task claiming/assignment | Custom lock files | `TaskUpdate` with `owner` | Built-in atomic claiming, prevents double-assignment |
| Teammate health monitoring | Custom heartbeat system | `TeammateIdle` hook + `TaskList` status checks | Built-in idle detection and task status tracking |
| Agent role/permission control | Custom role system | Agent type definitions + `plan_mode_required` | Built-in permission scoping and plan approval workflow |

**Key insight:** Agent Teams provides a complete coordination layer. Every piece of custom inter-agent infrastructure you might build already has a built-in equivalent. The migration is about switching from file-based coordination to API-based coordination, not building new infrastructure.

## Common Pitfalls

### Pitfall 1: Lead Context Overload

**What goes wrong:** The team lead accumulates context from monitoring all teammates, exhausts its context window, and starts losing track of team state.
**Why it happens:** Every teammate message, task update, and status check adds to the lead's context. With 4+ teammates in active workflows, context fills fast.
**How to avoid:** Keep lead prompts lean (coordination-only, no implementation detail). Use `TaskList` for status checks rather than asking teammates. Prefer structured task summaries over detailed messages.
**Warning signs:** Lead starts repeating instructions, losing track of which tasks are complete, or making contradictory coordination decisions.

### Pitfall 2: Teammate Spawned Without Team Awareness

**What goes wrong:** Teammate spawned via `Task()` but without the team communication protocol in its agent definition. It completes work but never messages the team or updates tasks.
**Why it happens:** Agent definitions need explicit Team Communication Protocol sections. The existing agent .md files don't have these.
**How to avoid:** Update every agent definition with a Team Communication Protocol section that explains: how to claim tasks via TaskUpdate, when to message teammates, when to broadcast, and how to respond to shutdown requests.
**Warning signs:** Teammate completes work but task status never changes. Other teammates never receive expected messages.

### Pitfall 3: One Team Per Session Limit

**What goes wrong:** Workflow tries to create multiple teams (e.g., a planning team and then an execution team) in the same session.
**Why it happens:** Agent Teams enforces one team per session. The session starts with the first TeamCreate.
**How to avoid:** Each GSD slash command (`/gsd:plan-phase`, `/gsd:execute-phase`) runs as its own session. Design each workflow to use exactly one team, created at start and deleted at end.
**Warning signs:** TeamCreate fails with error about existing team.

### Pitfall 4: No Session Resumption for In-Process Teammates

**What goes wrong:** Session is interrupted (timeout, crash, /clear) and all teammate state is lost.
**Why it happens:** In-process teammates do not persist across session boundaries. There is no resume mechanism.
**How to avoid:** File-based artifacts (PLAN.md, SUMMARY.md, RESEARCH.md) remain the persistent state layer. If a team session is lost, the orchestrator can detect existing artifacts and resume from the last checkpoint. This is why the CONTEXT.md locked decision "File-based artifacts remain the source of truth" is critical.
**Warning signs:** After session restart, TaskList returns empty even though work was partially complete.

### Pitfall 5: Shutdown Ordering

**What goes wrong:** `TeamDelete()` called before all teammates have acknowledged shutdown. Orphaned teammate processes or incomplete cleanup.
**Why it happens:** Teammates may be mid-task when shutdown is requested. They need time to finish current work and respond.
**How to avoid:** Send `SendMessage(shutdown_request)` to each teammate. Wait for shutdown_response (approve). Only then call TeamDelete. If a teammate rejects shutdown (still working), wait or force after timeout.
**Warning signs:** TeamDelete errors or warnings about active teammates.

### Pitfall 6: Task Status Lag

**What goes wrong:** Lead checks TaskList and sees stale status. Makes coordination decisions based on outdated task states.
**Why it happens:** Task status updates may lag slightly behind actual teammate progress, especially with in-process teammates.
**How to avoid:** When task ordering matters, wait for explicit teammate messages confirming completion rather than only relying on TaskList status. Use TaskCompleted hooks for critical quality gates.
**Warning signs:** Lead assigns follow-up work before predecessor is truly complete.

### Pitfall 7: Excessive Token Cost

**What goes wrong:** Token usage spikes dramatically compared to subagent mode. Each teammate is a full Claude Code session.
**Why it happens:** Subagents return a summarized result to the orchestrator. Teammates maintain full persistent sessions with message passing.
**How to avoid:** Only use teams for workflows that genuinely benefit from direct messaging (multi-agent coordination). Keep single-agent workflows (codebase-mapper, roadmapper for simple projects) as subagents. Size teams minimally.
**Warning signs:** Token costs 3-5x higher than equivalent subagent workflow with no quality improvement.

## Code Examples

Verified patterns from official documentation and reference architecture:

### Team Creation and Task Setup

```
// Source: Agent Teams documentation (code.claude.com/docs/en/agent-teams)
// Create team for plan-phase workflow
TeamCreate({ team_name: "gsd-plan-03", description: "Planning team for Phase 3: Monolith Decomposition" })

// Create tasks with dependency chain
TaskCreate({
  subject: "Research module decomposition patterns",
  description: "Investigate how to decompose 4600-line gsd-tools.js...",
  activeForm: "Researching decomposition patterns"
})
// Returns: { id: "1" }

TaskCreate({
  subject: "Create execution plans for decomposition",
  description: "Create PLAN.md files based on research findings...",
  activeForm: "Creating decomposition plans",
  addBlockedBy: ["1"]
})
// Returns: { id: "2" }

TaskCreate({
  subject: "Verify plan quality and coverage",
  description: "Check plans against 7 verification dimensions...",
  activeForm: "Verifying plan quality",
  addBlockedBy: ["2"]
})
// Returns: { id: "3" }
```

### Spawning Teammates into Team

```
// Source: Agent Teams documentation
// Spawn researcher as teammate
Task(
  team_name: "gsd-plan-03",
  name: "researcher",
  subagent_type: "gsd-phase-researcher",
  prompt: "You are the researcher on a planning team for Phase 3..."
)

// Spawn planner as teammate
Task(
  team_name: "gsd-plan-03",
  name: "planner",
  subagent_type: "gsd-planner",
  prompt: "You are the planner on a planning team for Phase 3..."
)

// Spawn checker as teammate
Task(
  team_name: "gsd-plan-03",
  name: "checker",
  subagent_type: "gsd-plan-checker",
  prompt: "You are the checker on a planning team for Phase 3..."
)
```

### Teammate Communication Protocol (Agent Definition Addition)

```markdown
<!-- Added to each gsd-*.md agent definition -->
<team_communication_protocol>

## When You Are a Teammate

When spawned into a team (you'll see team context in your session):

### Task Management
1. On start: `TaskList()` to see available tasks
2. Claim your task: `TaskUpdate({ taskId: "N", status: "in_progress", owner: "your-name" })`
3. On completion: `TaskUpdate({ taskId: "N", status: "completed" })`
4. Check for next: `TaskList()` after completing each task

### Messaging
- **Direct message:** `SendMessage({ type: "message", recipient: "teammate-name", content: "...", summary: "..." })`
- **Broadcast (sparingly):** `SendMessage({ type: "broadcast", content: "...", summary: "..." })`
- **Shutdown response:** When you receive a shutdown request, respond with:
  `SendMessage({ type: "shutdown_response", request_id: "...", approve: true })`

### Communication Guidelines
- Message teammates when you discover something relevant to their task
- Ask follow-up questions rather than making assumptions
- Keep messages concise â€” include enough context to be actionable
- After receiving a message from a teammate, respond with SendMessage (plain text output is NOT visible to teammates)

### File Artifacts
- Still write RESEARCH.md / PLAN.md / SUMMARY.md as before
- Files remain the persistent state layer
- Messages are ephemeral; important decisions should also be in files

</team_communication_protocol>
```

### Hook: TaskCompleted Quality Gate

```javascript
// Source: Claude Code Hooks documentation (code.claude.com/docs/en/hooks)
// ~/.claude/hooks/gsd-task-quality-gate.js
//
// TaskCompleted hook - validates task output quality
// Receives: task_id, task_subject, task_description, teammate_name, team_name
// Exit code 0: allow completion
// Exit code 2: prevent completion (stderr becomes feedback)

const { task_subject, teammate_name } = JSON.parse(process.env.CLAUDE_HOOK_EVENT || '{}');

// Example: verify executor created SUMMARY.md
if (task_subject.startsWith("Execute Plan")) {
  const fs = require('fs');
  const summaryPattern = task_subject.replace("Execute Plan ", "");
  // Check SUMMARY.md exists for the plan
  // Exit 2 with stderr feedback if missing
}

process.exit(0);
```

### Hook: TeammateIdle Monitoring (Limited)

```javascript
// Source: Claude Code Hooks documentation
// TeammateIdle hook - ONLY supports exit code hooks
// NO prompt or agent hook support
// Exit code 0 or 1: teammate goes idle (normal)
// Exit code 2: teammate continues (prevented from going idle)

const { teammate_name, team_name } = JSON.parse(process.env.CLAUDE_HOOK_EVENT || '{}');

// Log idle event for monitoring
console.error(`[${team_name}] ${teammate_name} going idle`);

// To prevent idle (keep teammate active): process.exit(2)
// Normal idle: process.exit(0)
process.exit(0);
```

### Graceful Team Shutdown

```
// Source: Agent Teams documentation
// Proper shutdown sequence
for teammate in [researcher, planner, checker]:
  SendMessage({
    type: "shutdown_request",
    recipient: teammate,
    content: "Phase planning complete. Please wrap up."
  })
  // Wait for shutdown_response with approve: true

// Only after all teammates acknowledged
TeamDelete()
```

### Reference: disler/claude-code-hooks-mastery Team Pattern

```markdown
# Source: github.com/disler/claude-code-hooks-mastery/plan_w_team.md
# Key patterns from reference implementation:

## Team Member Definition
team_members:
  - name: builder
    role: Implementation specialist
    agent_type: general-purpose
    resume: false   # Fresh context each time

  - name: validator
    role: Quality assurance
    agent_type: general-purpose
    resume: false

## Task Dependencies
TaskCreate({ subject: "Build component", activeForm: "Building..." })
TaskCreate({ subject: "Validate component", addBlockedBy: ["1"], activeForm: "Validating..." })

## Key Insight: Meta-Agent Pattern
# A meta-agent generates .claude/agents/team/*.md files dynamically
# based on task descriptions. This allows task-specific agent creation
# rather than fixed agent roles.
```

## State of the Art

| Aspect | Current (Subagents) | Target (Agent Teams) | Impact |
|--------|---------------------|---------------------|--------|
| Agent lifecycle | Fire-and-forget Task() | Persistent sessions via Team | Enables follow-up questions, iterative collaboration |
| Communication | File-based only | Direct messaging + files | Real-time coordination, reduced revision latency |
| Coordination | Orchestrator manages all state | Shared TaskList with self-coordination | Reduces orchestrator bottleneck, agents claim own work |
| Wave execution | Frontmatter depends_on/wave | addBlockedBy task dependencies | Programmatic dependency resolution vs. static frontmatter |
| Revision loops | Sequential: planner -> orchestrator -> checker -> orchestrator -> planner | Direct: planner <-> checker | Eliminates orchestrator bottleneck, faster iterations |
| Context loading | Serialized into spawn prompt | Each session loads CLAUDE.md + MCP servers | Richer context per agent, but higher token cost |
| Error recovery | Orchestrator restarts from last completed subagent | File artifacts persist, team recreated from checkpoint | Same resilience due to file-based source of truth |

**Experimental status:**
- Agent Teams requires `CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1` environment variable
- The `EXPERIMENTAL` prefix signals this API may change
- `teammateMode` options: `in-process` (default, same process), `tmux` (separate terminals), `auto` (Claude chooses)
- In-process mode is recommended for programmatic workflows (no tmux dependency)

**Key limitations discovered:**
- No session resumption: if session dies, team is lost (files persist though)
- One team per session: cannot create multiple teams sequentially
- No nested teams: a teammate cannot create its own team
- Team lead is fixed: cannot change the lead after creation
- TeammateIdle hook: only exit code hooks, NO prompt/agent hooks
- TaskCompleted hook: full support (exit code + prompt + agent hooks)
- Shutdown can be slow: teammates may need time to wrap up current work

## Open Questions

1. **Team size limits and performance characteristics**
   - What we know: Documentation doesn't specify maximum teammates per team
   - What's unclear: Performance degradation with 5+ teammates, message delivery latency at scale
   - Recommendation: Start with small teams (3-4 teammates for plan-phase), measure performance, scale up cautiously

2. **Task status consistency guarantees**
   - What we know: TaskList provides current status, addBlockedBy prevents premature task start
   - What's unclear: Exact consistency model (eventual? strong?), race conditions on task claiming
   - Recommendation: Use explicit SendMessage confirmations for critical ordering rather than relying solely on TaskList polling

3. **Agent definition loading in team context**
   - What we know: Teammates load CLAUDE.md and MCP servers automatically from project context
   - What's unclear: Whether `subagent_type: "gsd-planner"` causes the teammate to read `~/.claude/agents/gsd-planner.md` automatically or if the agent definition must be included in the spawn prompt
   - Recommendation: Test both approaches during implementation. Include agent definition path in spawn prompt as fallback: "First, read ~/.claude/agents/gsd-planner.md..."

4. **Fallback detection mechanism**
   - What we know: TeamCreate should fail if Agent Teams is not enabled
   - What's unclear: Exact error type/message when teams are unavailable, whether workflows can catch errors in prompt-based logic
   - Recommendation: Test TeamCreate failure mode. Design fallback detection as the first step in each workflow.

5. **Cost implications per workflow**
   - What we know: Each teammate is a full Claude Code session with 200k context window
   - What's unclear: Actual token multiplier compared to subagent mode for GSD workflows
   - Recommendation: Instrument token usage for the first migrated workflow (plan-phase) and compare against subagent baseline before proceeding to other workflows

6. **Interaction between existing hooks and team hooks**
   - What we know: GSD has existing hooks (SessionStart with gsd-check-update.js, statusLine with gsd-statusline.js). Agent Teams adds TeammateIdle and TaskCompleted hook events.
   - What's unclear: Whether existing SessionStart hooks fire for teammate sessions, whether statusLine applies to teammate contexts
   - Recommendation: Test hook behavior with a simple team before implementing complex workflows

## Sources

### Primary (HIGH confidence)
- Claude Code Agent Teams documentation (code.claude.com/docs/en/agent-teams) - Team creation, task management, messaging, lifecycle, configuration, limitations. Verified 2026-02-09.
- Claude Code Hooks documentation (code.claude.com/docs/en/hooks) - TeammateIdle and TaskCompleted hook events, exit code semantics, prompt/agent hook support matrix. Verified 2026-02-09.
- Current GSD agent definitions (~/.claude/agents/gsd-*.md) - All 11 agent types reviewed for communication needs and migration requirements. Read directly from filesystem.
- Current GSD workflow definitions (~/.claude/get-shit-done/workflows/*.md) - All 3 primary workflows + execute-plan reviewed for spawning patterns and coordination flow. Read directly from filesystem.

### Secondary (MEDIUM confidence)
- disler/claude-code-hooks-mastery (github.com/disler/claude-code-hooks-mastery) - Builder/validator team pattern, plan_w_team.md orchestration, meta-agent pattern. Verified via direct repository fetch 2026-02-09. Community reference, not official.
- Addy Osmani blog on Claude Code Agent Teams patterns - Team design principles, delegate mode best practices, task sizing guidance. Verified via web fetch 2026-02-09.

### Tertiary (LOW confidence)
- Agent Teams performance characteristics at scale (5+ teammates) - Based on general understanding, not tested or documented. Flag for validation during implementation.
- Task status consistency model - Inferred from documentation wording, not explicitly specified. Flag for validation.
- Exact token cost multiplier (teams vs subagents) - Not documented, depends on workflow specifics. Requires empirical measurement.

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Agent Teams API is official and documented, all tools verified against current docs
- Architecture patterns: MEDIUM-HIGH - Patterns derived from official docs + reference implementation, but GSD-specific team orchestration patterns are novel (no prior art for this specific migration)
- Pitfalls: MEDIUM - Common pitfalls from official docs and community sources, but GSD-specific edge cases (wave execution, checkpoint handling, file ownership) need validation during implementation
- Code examples: MEDIUM - API calls verified against documentation, but exact workflow integration patterns are extrapolated from reference architecture

**Research date:** 2026-02-09
**Valid until:** 2026-03-09 (30 days - Agent Teams is experimental, API may change with Claude Code updates)
