---
phase: 02-error-handling-security
plan: 04
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - get-shit-done/bin/gsd-tools.js
autonomous: true

must_haves:
  truths:
    - "Running any command with invalid input produces a specific rejection message instead of silent failure or stack trace"
    - "Phase numbers are validated as numeric format (digits, optional dot+digits) before use"
    - "JSON string arguments are validated before JSON.parse and produce clear error on malformed input"
    - "Field names are validated as safe identifiers before use in operations"
    - "File path arguments reject traversal patterns (../) with explanatory error"
  artifacts:
    - path: "get-shit-done/bin/gsd-tools.js"
      provides: "Input validation for all command handlers"
      contains: "function validatePhaseNumber"
  key_links:
    - from: "command dispatch (main switch)"
      to: "validation functions"
      via: "validate before execute pattern"
      pattern: "validate(Phase|Field|Json|Path)"
---

<objective>
Add input validation to all command handlers in gsd-tools.js so invalid input produces specific rejection messages.

Purpose: Requirement SECU-01. Users (and AI agents calling gsd-tools) get immediate, clear feedback on bad input instead of silent failures, stack traces, or corrupted state.
Output: Validation functions and validated command entry points in gsd-tools.js.
</objective>

<execution_context>
@/Users/naveennegi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/naveennegi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@get-shit-done/bin/gsd-tools.js
@.planning/phases/02-error-handling-security/02-01-SUMMARY.md
@.planning/phases/02-error-handling-security/02-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create validation utility functions</name>
  <files>get-shit-done/bin/gsd-tools.js</files>
  <action>
    Add validation utility functions near the other utilities (after escapeRegExp/sanitizeJson from Plan 02):

    ```
    function validatePhaseNumber(phase) {
      if (!phase) return 'Phase number required';
      // Accept: "01", "1", "02", "2", "01.1", "1.1", "12", "12.3"
      if (!/^\d+(\.\d+)?$/.test(phase)) {
        return `Invalid phase number '${phase}'. Expected format: N or N.N (e.g., "01", "2", "1.1")`;
      }
      return null; // valid
    }

    function validateFieldName(field) {
      if (!field) return 'Field name required';
      // Allow alphanumeric, underscores, hyphens, spaces (for markdown field names like "Current focus")
      if (!/^[\w\s-]+$/i.test(field)) {
        return `Invalid field name '${field}'. Only letters, numbers, underscores, hyphens, and spaces allowed`;
      }
      if (field.length > 100) {
        return `Field name too long (${field.length} chars, max 100)`;
      }
      return null; // valid
    }

    function validateJsonString(str, paramName) {
      if (!str) return `${paramName || 'JSON string'} required`;
      try {
        JSON.parse(str);
        return null; // valid
      } catch (e) {
        return `Invalid JSON for ${paramName || 'input'}: ${e.message}`;
      }
    }
    ```

    These functions return null on success, error message string on failure. This pattern works with the existing code structure (no exceptions for validation).
  </action>
  <verify>Run `node --test get-shit-done/bin/gsd-tools.test.js` -- all tests pass (functions are additive).</verify>
  <done>validatePhaseNumber, validateFieldName, validateJsonString utilities exist in gsd-tools.js.</done>
</task>

<task type="auto">
  <name>Task 2: Apply validation to all command handlers</name>
  <files>get-shit-done/bin/gsd-tools.js</files>
  <action>
    Apply validation at the entry point of each command handler. The pattern:
    ```
    const err = validatePhaseNumber(phase);
    if (err) { error(err, EXIT_USAGE); return; }
    ```

    **Phase number validation** -- apply to:
    - `cmdFindPhase(cwd, phase, raw)`: validate `phase` arg
    - `cmdPhaseNextDecimal(cwd, phase, raw)`: validate `phase` arg
    - `cmdPhaseAdd(cwd, description, raw)`: validate if description includes phase number
    - `cmdPhaseInsert(cwd, afterPhase, description, raw)`: validate `afterPhase`
    - `cmdPhaseRemove(cwd, phase, force, raw)`: validate `phase`
    - `cmdPhaseComplete(cwd, phase, raw)`: validate `phase`
    - `cmdRoadmapGetPhase(cwd, phase, raw)`: validate `phase`
    - `cmdInitExecutePhase(cwd, phase, includes, raw)`: validate `phase`
    - `cmdInitPlanPhase(cwd, phase, includes, raw)`: validate `phase`
    - `cmdInitVerifyWork(cwd, phase, raw)`: validate `phase` (if provided)
    - `cmdInitPhaseOp(cwd, phase, raw)`: validate `phase` (if provided)
    - `cmdPhasePlanIndex(cwd, phase, raw)`: validate `phase`
    - `cmdVerifyPhaseCompleteness(cwd, phase, raw)`: validate `phase`

    **Field name validation** -- apply to:
    - `cmdStateUpdate(cwd, field, value)`: validate `field`
    - `cmdStateGet(cwd, section, raw)`: validate `section` (if provided)
    - `cmdStatePatch(cwd, patches, raw)`: validate each key in `patches`
    - `cmdFrontmatterGet(cwd, filePath, field, raw)`: validate `field` (if provided)
    - `cmdFrontmatterSet(cwd, filePath, field, value, raw)`: validate `field`

    **JSON string validation** -- apply to:
    - `cmdFrontmatterMerge`: validate `data` is parseable JSON BEFORE calling JSON.parse
    - `template fill --fields`: validate `args[fieldsIdx + 1]` is parseable JSON in the main switch BEFORE passing to cmdTemplateFill
    - `cmdFrontmatterSet --value`: validate value as JSON when it looks like JSON (starts with { or [)

    **Path validation** -- apply to commands that accept file paths (already partially handled by Plan 02's validatePath, but add explicit `../` check at command entry):
    - For all `filePath` args: reject if contains `..` segments going above project root

    IMPORTANT: Only add validation at the command handler entry point. Do NOT add validation deep inside helper functions -- it would change internal contracts and break tests.

    IMPORTANT: Commands that currently accept null/undefined for optional parameters (like `cmdStateGet` with no section) must continue to work. Only validate when the parameter IS provided.

    Exit code for all validation failures: EXIT_USAGE (2).
  </action>
  <verify>
    1. Run `node --test get-shit-done/bin/gsd-tools.test.js` -- all tests pass
    2. Test bad phase number: `node get-shit-done/bin/gsd-tools.js find-phase "abc"; echo $?` returns error message + exit code 2
    3. Test bad field name: `node get-shit-done/bin/gsd-tools.js state update "__proto__" "hack"; echo $?` returns error + exit code 2
    4. Test bad JSON: `node get-shit-done/bin/gsd-tools.js frontmatter merge test.md --data "{bad json}"; echo $?` returns error + exit code 2
  </verify>
  <done>All command handlers validate input at entry. Bad phase numbers, field names, JSON strings, and file paths produce specific rejection messages with EXIT_USAGE exit code. All existing tests pass.</done>
</task>

</tasks>

<verification>
1. `node --test get-shit-done/bin/gsd-tools.test.js` passes all tests
2. `grep -c 'validatePhaseNumber\|validateFieldName\|validateJsonString' get-shit-done/bin/gsd-tools.js` shows 15+ usages
3. Bad inputs produce specific error messages (not stack traces or silent failures)
4. Optional parameters still work when omitted (null/undefined)
</verification>

<success_criteria>
- Every command that takes phase numbers validates them
- Every command that takes field names validates them
- Every command that takes JSON strings validates them before parsing
- All validation failures exit with code 2 (EXIT_USAGE)
- All existing characterization tests pass unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/02-error-handling-security/02-04-SUMMARY.md`
</output>
