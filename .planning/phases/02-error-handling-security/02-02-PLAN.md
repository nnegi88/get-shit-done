---
phase: 02-error-handling-security
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - get-shit-done/bin/gsd-tools.js
  - bin/install.js
autonomous: true

must_haves:
  truths:
    - "User-provided strings are escaped before use in RegExp constructors"
    - "Compiled regex patterns are cached at module scope for reuse"
    - "JSON.parse results are sanitized to remove __proto__, constructor, and prototype keys"
    - "File path arguments outside project root or following symlinks are rejected with an explanatory error"
  artifacts:
    - path: "get-shit-done/bin/gsd-tools.js"
      provides: "Security utility functions (escapeRegExp, sanitizeJson, validatePath)"
      contains: "function escapeRegExp"
    - path: "bin/install.js"
      provides: "sanitizeJson applied to parseJsonc output"
      contains: "sanitizeJson"
  key_links:
    - from: "new RegExp() call sites"
      to: "escapeRegExp utility"
      via: "wrapping user input before RegExp construction"
      pattern: "escapeRegExp\\("
    - from: "JSON.parse call sites"
      to: "sanitizeJson utility"
      via: "post-parse sanitization"
      pattern: "sanitizeJson\\("
    - from: "file path resolution"
      to: "validatePath utility"
      via: "scope check before file operations"
      pattern: "validatePath\\("
---

<objective>
Create security utility functions and apply them across the codebase: RegExp escaping, JSON sanitization, and path scope validation.

Purpose: Eliminate security vectors identified in CONCERNS.md -- prototype pollution via JSON.parse, regex injection via user strings in RegExp constructors, and path traversal via unscoped file arguments.
Output: Security utility functions in gsd-tools.js and install.js with all existing call sites hardened.
</objective>

<execution_context>
@/Users/naveennegi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/naveennegi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@get-shit-done/bin/gsd-tools.js
@bin/install.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add RegExp escaping utility and harden all new RegExp() call sites</name>
  <files>get-shit-done/bin/gsd-tools.js</files>
  <action>
    IMPORTANT: Some call sites already escape regex characters (e.g., line 1007: `section.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')`). This task standardizes the pattern.

    1. Add `escapeRegExp` utility function near the top of gsd-tools.js (after require statements):
    ```
    function escapeRegExp(str) {
      return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }
    ```

    2. Create a module-scope regex cache object:
    ```
    const regexCache = new Map();
    function getCachedRegex(pattern, flags) {
      const key = pattern + '/' + (flags || '');
      let re = regexCache.get(key);
      if (!re) {
        re = new RegExp(pattern, flags);
        regexCache.set(key, re);
      }
      return re;
    }
    ```

    3. Replace all inline `field.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')` calls with `escapeRegExp(field)`. There are approximately 4-5 such inline escapes (lines ~1007, 1038, etc.).

    4. Audit ALL 26 `new RegExp()` call sites. For each:
       - If the variable in the pattern comes from user input (command args): ensure `escapeRegExp()` is applied
       - If the variable is already escaped: replace inline escape with `escapeRegExp()` call
       - If the pattern is a constant string: no change needed, but consider using `getCachedRegex()` for patterns used in loops

    5. For regex patterns used in frequently-called functions (e.g., `stateReplaceField`, `cmdStatePatch`, `cmdStateGet`), use `getCachedRegex()` to avoid recompilation. NOTE: only cache patterns that are reused with the same arguments. Dynamic patterns with user-varying input should NOT be cached (the cache would grow unbounded).

    Key call sites to update (verify each uses escapeRegExp on user input):
    - Line ~408: `blockPattern` in parseMustHavesBlock -- uses `blockName` (from YAML key, not user input -- safe but standardize)
    - Line ~839: `phasePattern` in findPhaseInternal -- uses normalized phase number
    - Line ~909: `decimalPattern` -- uses normalized phase number
    - Lines ~1010, 1018, 1039, 1068, 1084, 1091: STATE.md field patterns -- field comes from command args, MUST escape
    - Line ~1856: stateReplaceField -- field from args, MUST escape
    - Line ~2382: key_links verification -- pattern from PLAN.md frontmatter
    - Line ~2485, 2612, 2625, 2644, 2732, 2834, 2841, 2845: roadmap/phase operations -- phase numbers
    - Lines ~2863-2887: phase renumbering -- phase numbers
    - Lines ~2955, 2963, 2973: milestone operations -- phase numbers
  </action>
  <verify>Run `node --test get-shit-done/bin/gsd-tools.test.js` -- all tests pass. Specifically verify state update tests and frontmatter tests still work correctly since those use RegExp with field names.</verify>
  <done>escapeRegExp utility exists, all 26 new RegExp() sites audited, user-input variables wrapped with escapeRegExp(), inline escape patterns replaced with utility call, getCachedRegex available for hot-path patterns.</done>
</task>

<task type="auto">
  <name>Task 2: Add JSON sanitization and path validation utilities</name>
  <files>get-shit-done/bin/gsd-tools.js, bin/install.js</files>
  <action>
    **Part A: JSON prototype pollution sanitization**

    1. Add `sanitizeJson` utility in gsd-tools.js (near escapeRegExp):
    ```
    function sanitizeJson(obj) {
      if (obj === null || typeof obj !== 'object') return obj;
      if (Array.isArray(obj)) return obj.map(sanitizeJson);
      const clean = {};
      for (const key of Object.keys(obj)) {
        if (key === '__proto__' || key === 'constructor' || key === 'prototype') continue;
        clean[key] = sanitizeJson(obj[key]);
      }
      return clean;
    }
    ```

    2. Apply sanitizeJson to all JSON.parse results from user input in gsd-tools.js:
    - Line ~2088: `cmdFrontmatterSet` -- `parsedValue = JSON.parse(value)` becomes `parsedValue = sanitizeJson(JSON.parse(value))`
    - Line ~2102: `cmdFrontmatterMerge` -- `mergeData = JSON.parse(data)` becomes `mergeData = sanitizeJson(JSON.parse(data))`
    - Line ~4335: `template fill --fields` -- `JSON.parse(args[fieldsIdx + 1])` becomes `sanitizeJson(JSON.parse(args[fieldsIdx + 1]))`
    - Line ~175: `loadConfig` -- `JSON.parse(raw)` becomes `sanitizeJson(JSON.parse(raw))`
    - Line ~639: config loading -- `JSON.parse(fs.readFileSync(configPath, 'utf-8'))` becomes `sanitizeJson(JSON.parse(...))`

    3. In bin/install.js, add the same sanitizeJson function (duplicated -- Phase 3 decomposition will extract to shared module). Apply to:
    - Line ~1029: parseJsonc return -- `return sanitizeJson(JSON.parse(result))`
    - Line ~185: settings.json loading -- `sanitizeJson(JSON.parse(...))`
    - Line ~925: config.json loading -- `sanitizeJson(JSON.parse(...))`
    - Line ~1213: manifest loading -- `sanitizeJson(JSON.parse(...))`
    - Line ~1254: meta loading -- `sanitizeJson(JSON.parse(...))`

    **Part B: Path scope validation**

    4. Add `validatePath` utility in gsd-tools.js:
    ```
    function validatePath(filePath, cwd) {
      const resolved = path.resolve(cwd, filePath);
      // Check if resolved path is within project root
      if (!resolved.startsWith(cwd + path.sep) && resolved !== cwd) {
        return { valid: false, error: `Path '${filePath}' resolves outside project root` };
      }
      // Check for symlink traversal
      try {
        const real = fs.realpathSync(resolved);
        if (!real.startsWith(cwd + path.sep) && real !== cwd) {
          return { valid: false, error: `Path '${filePath}' follows symlink outside project root` };
        }
      } catch {
        // File doesn't exist yet, that's OK for write operations
      }
      return { valid: true, resolved };
    }
    ```

    5. Apply validatePath to commands that accept file path arguments from users:
    - `cmdFrontmatterGet` (line ~2068): Before resolving `filePath`, validate scope
    - `cmdFrontmatterSet` (line ~2083): Before resolving `filePath`, validate scope
    - `cmdFrontmatterMerge` (line ~2097): Before resolving `filePath`, validate scope
    - `cmdVerifyReferences` (line ~2240): Before resolving `filePath`, validate scope
    - `cmdVerifySummary`: Before resolving summary path, validate scope

    For each: After the path is resolved (via `path.isAbsolute ? filePath : path.join(cwd, filePath)`), add:
    ```
    const pathCheck = validatePath(fullPath, cwd);
    if (!pathCheck.valid) { error(pathCheck.error, EXIT_FILESYSTEM); return; }
    ```

    NOTE: `validatePath` uses EXIT_FILESYSTEM constant from Plan 01. Since both plans are Wave 1, handle gracefully: if EXIT_FILESYSTEM is not defined yet (Plan 01 not merged), use hardcoded 4 as fallback. Prefer defining the constant if Plan 01 is already applied.

    IMPORTANT: Do NOT add path validation to internal paths that gsd-tools constructs itself (e.g., `.planning/STATE.md`). Only validate paths that come from user command arguments.
  </action>
  <verify>Run `node --test get-shit-done/bin/gsd-tools.test.js` and `node --test bin/install.test.js` -- all tests pass. Test that `node get-shit-done/bin/gsd-tools.js frontmatter get ../../etc/passwd` returns an error about path scope.</verify>
  <done>sanitizeJson strips __proto__/constructor/prototype from all JSON.parse results. validatePath rejects paths outside project root and symlink traversals. escapeRegExp used at all new RegExp() sites with user input. All existing tests pass.</done>
</task>

</tasks>

<verification>
1. `node --test get-shit-done/bin/gsd-tools.test.js` passes all existing tests
2. `node --test bin/install.test.js` passes all existing tests
3. `grep -c 'escapeRegExp' get-shit-done/bin/gsd-tools.js` shows 10+ usages (utility + call sites)
4. `grep -c 'sanitizeJson' get-shit-done/bin/gsd-tools.js` shows 5+ usages
5. `grep -c 'sanitizeJson' bin/install.js` shows 5+ usages
6. `grep -c 'validatePath' get-shit-done/bin/gsd-tools.js` shows 5+ usages
</verification>

<success_criteria>
- escapeRegExp utility exists and is used at all new RegExp() sites with user-provided input
- getCachedRegex utility exists for hot-path pattern reuse
- sanitizeJson strips prototype pollution keys from all JSON.parse results in both files
- validatePath rejects paths outside project root and symlink traversals
- All existing characterization tests pass unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/02-error-handling-security/02-02-SUMMARY.md`
</output>
